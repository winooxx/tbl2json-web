<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>tbl2json</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" media="screen" href="main.css" />
</head>

<body>
  <div class="old_tbl">
    <h2>待转换的tbl</h2>
    <div class="notice">
      请选择tbl：
      <input type="file" id="upfile" class="upfile">
      <label for="upfile" class="ui-button ui-button-warning">选择tbl文件</label>
    </div>
    <textarea name="tbl" id="tbl" cols="30" rows="10" readonly></textarea>
  </div>
  <div class="new_json">
    <h2>转换后的json</h2>
    <textarea name="new_json" id="new_json" cols="30" rows="10" readonly></textarea>
  </div>

  <script>
    const tblInput = document.getElementById('tbl');
    const jsonOutput = document.getElementById('new_json');
    const eleFile = document.getElementById('upfile');
    const convertEntries = [];
    let result = null;

    // 创建一个 FileReader 用来读取本地文件
    const reader = new FileReader();
    reader.onload = (e) => {
      result = e.target.result;
      // 把读到的内容打在 textarea 内
      tblInput.value = e.target.result;

      // 正则匹配规则
      // 1. 匹配所有除换行符以外的空白字符，删除
      // 2. 匹配所有以 // 开头的文字（即注释），删除
      // 3. 匹配所有的"（英文双引号），删除
      result = result.replace(/ +/gi, "").replace(/\/\/.*/g, "").replace(/"/gi, "");

      // Auto-generated code
      const regex = /(?<=\()\S+(?=\))/g;

      let m;

      while ((m = regex.exec(result)) !== null) {
        // This is necessary to avoid infinite loops with zero-width matches
        if (m.index === regex.lastIndex) {
          regex.lastIndex++;
        }

        // The result can be accessed through the `m`-variable.
        // m.forEach((match, groupIndex) => {
        //   console.log(`Found match, group ${groupIndex}: ${match}`);
        // });
        m.forEach((match) => {
          const temp = match.split(',');
          const entry = {
            id: parseInt(temp[0]),
            name: temp[1],
            ver: parseInt(temp[2]),
            bpm: parseInt(temp[3]),
            sortID: parseInt(temp[4]),
            dress: parseInt(temp[5]),
            dark: parseInt(temp[6]),
            mile: parseInt(temp[7]),
            rank: parseInt(temp[8]),
            vl: parseInt(temp[9]),
            event: parseInt(temp[10]),
            rec: parseInt(temp[11]),
            pvStart: parseInt(temp[12]),
            pvEnd: parseInt(temp[13]),
            songLength: parseInt(temp[14]),
            offRanking: parseInt(temp[15]),
            adDef: parseInt(temp[16]),
            remaster: parseInt(temp[17]),
            specialPV: parseInt(temp[18]),
            challengeTrack: parseInt(temp[19]),
            bonus: parseInt(temp[20]),
            genreID: parseInt(temp[21]),
            title: temp[22],
            artist: temp[23],
            sort_jp_index: parseInt(temp[24]),
            sort_ex_index: parseInt(temp[25]),
            filename: temp[26]
          };
          convertEntries.push(entry);
        })
      };
      jsonOutput.value = JSON.stringify(convertEntries);
    };

    eleFile.onchange = () => {
      const file = event.target.files[0];
      if (file) {
        reader.readAsText(file);
      }
    };
  </script>
</body>

</html>